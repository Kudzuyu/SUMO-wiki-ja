# 基本的な定義

[原文ページ](https://sumo.dlr.de/wiki/Simulation/Basic_Definition)

ここではシミュレーションのモジュールである[SUMO]()と[SUMO-GUI]()に必要な入力が示されています。

## 入力ファイル

### 道路ネットワーク

シミュレーションのためには、オプション **--net-file `<NETWORK_FILE>`** (または **-n `<NETWORK_FILE>`**)を使ってSUMO道路ネットワークを与える必要があります。
ネットワークは通常[NETCONVERT]()か[NETGENERATE]()によって生成されます。

### 交通需要(経路)

シミュレーションには車が必要です。
車には一般的に[車両タイプ]()、[車両群]()、[車両の経路]()が含まれています。
経路は一般にオプション **--route-files `<ROUTE_FILE> `[, `<ROUTE_FILE>`]* ** (または **-r `<ROUTE_FILE> `[, `<ROUTE_FILE>`]* **)を使って与えられます。
見ての通り、一つのシミュレーションに対して複数の経路を使うことが可能です。

経路はソートされていなければなりません。
巨大なネットワークで百万もの経路を使う必要があるからです。
普通のPCでこれを可能にするには、全部の経路をメモリに載せないことしかありません。
パラメータ ** --route-files `<ROUTES_FILE>`[, `<ROUTES_FILE>`]* ** によって与えられる全てのファイルは一つずつ読みこまれます。
開始時間ステップから新しい経路がnステップごとに読みこまれます。
n は **--route-steps `<INT>`**を使うことで操作でき、0以下の場合はSUMO/SUMO-GUIは全てのファイルを読み込ませることを強制します。

車両の定義を含んだ経路ファイルを[追加ファイル]()として[SUMO]()/[SUMO-GUI]()に与えることもできます。

### 追加のファイル

一つ以上の[追加ファイル]() が、情報の追加に使われます。

* インフラ関係: [交通信号プログラム]()、と[バス停]()
* 追加の視覚化: [POIs]()と[polygons]()(例: 河川や家屋)
* 動的シミュレーション操作構造: [各種の速度標識]()や[リルーター]() 
* 需要関係: [車両タイプ]()と[経路]()

### 読みとり順序

ロード順序は次のようになっています:

1. ネットワーク読み込み
1. オプションに表われた順に、追加ファイルを上から順に読み込み
1. ルートファイルが開かれ、最初のnステップを読み込み
1. nステップ毎に、次のnステップ分のルートを読み込み

## シミュレーション期間の定義

シミュレーションにはシミュレートされる期間が必要です。
[SUMO]()および[SUMO-GUI]()においては、**--begin [`<TIME>`](basics_notation.md#データタイプ)** (または **-b [`<TIME>`](basics_notation.md#データタイプ)**) と**--end [`<TIME>`](basics_notation.md#データタイプ)**(**-e [`<TIME>`](basics_notation.md#データタイプ))**を使って与えます。
オプション**--end**が与えられているかどうかがシミュレーションに影響を及ぼすことに注意してください。
詳細を以下に示します。

シミュレーションは**--begin**で与えられた時間から始まり、デフォルトでは0です。
開始時間より早い出発時間(`depart`)を持つ全ての車両は捨てられます。

シミュレーションはステップごとに実行されます。

シミュレーションは以下のどれかの状況で終了します:

* 終了ステップが**--end**で与えらており、そのステップに到達したとき()
* **--end**が与えられず、全ての車がシミュレートされた後。最後の車がシミュレーション範囲の外に出たときがこれにあたります。[TraCI]()による接続がある場合は、最後の車が消えてもシミュレーションは続きます(場合によっては「永遠に」)
* [TraCI]()からのcloseコマンドを受けとったとき

## ステップ長の定義

SUMO/SUMO-GUIはデフォルトで一秒一ステップでシミュレーションを行ないます。
**--step-length**を使うことでこの設定を上書きできます。`<TIME>`は秒で与えられますが、実数を入力することができます。
結果として、**--step-length 0.01**はシミュレーションを10ミリ秒単位で動かします。

**--default.action-step-length[`<TIME>`](basics_notation.md#データタイプ)**オプションを指定すると、車は指定されたステップごとにしか、車線変更や加速などの順応動作を行なわなくなります(標準では各ステップごとに行なう)。
行動間隔(action-step-length)をシミュレーションのステップ長と異なった長さにすると[統一メソッド](#統一メソッドの定義)は自動的に「弾道型」に変更されます。

行動間隔をシミュレーションステップ長よりも長くするとシミュレーションは早くなりますが、仮定されている反応時間タウより長い値は、車の衝突を起こすかもしれません。
詳細は[車両タイプ]()と[車の追従]()に関する説明を参照してください。

!!! note "注"
    いくつかの使用可能な追従モデルはステップ長1秒のシミュレーション用に開発されていることに注意してください。
    その他のステップ長ではうまく動かないかもしれません。

## 統一メソッドの定義

シミュレーションにおけるダイナミクスを管理する数学的な統一手法が二つあります。
現在標準はオイラー更新(Euler-update)で、ステップ中で車が等速運動をすると仮定します。
これにかわるものとしてSUMOはステップ中で等加速度運動を仮定する弾道型更新(Ballistic-update)が提案されています。
弾道型更新は**--step-method.ballistic**オプションを指定するか、次の文を設定ファイルにいれることで有効化できます。

```
<processing>
    <step-method.ballistic value="true"/>
</processing>
```

特に、大きな時間ステップ(例: 1秒)において連続的ダイナミクスを用いた車の追従モデルでは弾道型更新はより現実的なダイナミクスを生みだします。
[Martin Treiber, Venkatesan Kanagaraj, Comparing Numerical Integration Schemes for Time-Continuous Car-Following Models](http://arxiv.org/abs/1403.4881) も参照してください。

弾道型更新は車の位置を、現在の速度ではなくタイムステップ間の平均速度を使ってアップデートします。
ステップ長1秒において次の例を考えてみましょう:

車が時刻tにおいて、位置xにあり4.5m/sで動いている時に、時刻t+1で速度が0になるようにブレーキを踏んだ。

* オイラー更新: 車はt+1ステップで、位置xに停止します(即時減速)。
* 弾道型更新: 車はt+1ステップで、位置x+2.25に停止します(連続減速)。

!!! caution "警告"
    現在弾道型更新はサブレーンモデルとの組みあわせではうまく動きません。
    詳しくは[issue #2581]を参照してください。